# react web game

- setInterval, setTimeout 같은 비동기 함수는 컴포넌트가 제거되기 전에 꼭 clear해주어야 한다.
  - memory 누수 문제 해결
- hooks
  - useMemo()
    - 최초 마운트시 호출되어 함수가 리턴하는 값을 기억한다. 두번째 인자는 빈 배열([])로 useEffect와 동일하고 useEffect처럼 두번째 인자가 변경되면 useMemo가 재실행된다.
    - useState에 초기화값을 어떤 함수의 리턴값으로 지정할 때, 사용된다. 하지만 이런 상황에서는 useState 내부에서 함수를 호출하는 방식으로 작성하지 말고 함수 그 자체만 입력하면 리턴값을 기억하게하는 방식이 권장된다.
  - useCallback()
    - 함수 자체를 기억한다.
    - 꼭 써야하는 경우가 있는데, 자식 컴포넌트에게 함수를 props로 넘길때이다. 그냥 함수를 넘겨버리면 매번 새로운 함수를 자식에게 전달하기 때문에 자식 입장에서는 계속 props가 새로 들어온다고 인식하고 매번 리렌더링을 하게되어 성능 저하가 발생한다.
    - useCallback()을 사용할 때 주의 사항은 최초 함수를 기억해두고, 값이 변화해도 처음에 기억한 함수를 실행할 수 있기 때문에, 변화할 것같은 값을 []빈배열에 집어넣어서 변경되는 값을 감지하게 만든다.
  - useReducer()
    - 여러 state를 한번에 관리할 수 있다.
    - `type` 키를 가지고, `action` 을 발생 시킨다.
    - action을 발생시킬 땐, dispatch 메서드를 사용하여 어떤 타입으로 실행하고, 변경시킬 값을 넘겨 줄 수 있게 매개변수를 지정할 수도 있다.
    - reducer에서 action을 정의할 수 있다.
    - 이 개념은 Redux에서 가져온 개념이고, 작은 프로젝트를 할 때, 유용하게 사용될 수 있지만 규모가 커지면 결국 Redux를 사용해야 한다.
    - dispatch는 비동기로 움직이기 때문에 유의한다.
- hooks 유의 사항
  - hooks 실행 순서에 유의한다.
  - 조건문 안에 넣지 말자. 순서가 꼬인다.
  - hooks 내부에 다른 hooks를 넣어 사용하지말자.
  - 반복문 내부에 hooks를 넣어도 되지만 권장되진 않는다.
